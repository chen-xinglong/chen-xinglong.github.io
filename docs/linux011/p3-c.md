
## 3.3 C语言程序

GNU gcc 对 ISO 标准 C89 描述的 C语言进行了一些扩展。

### 3.3.1 C程序编译和链接

使用gcc汇编器编译C语言程序时通常会经过四个处理阶段，即**预处理阶段、编译阶段、汇编阶段和链接阶段**，如下图所示。

![p3-1](../linux011image/p3-c/p3-1.png)


- 在前处理阶段中，gcc 会把C程序传递给 C 前处理器CPP，对 C语言程序中**指示符和宏**进行替换处理，
输出纯C语言代码；

- 在编译阶段，gcc把C语言程序编译生成对应的与机器相关的as汇编语言代码；

- 在汇编阶段，as汇编器会把汇编代码转换成机器指令，并以特定二进制格式输出保存在标文件中；最后GNU ld链接器把程序的相关目标文件组合链接在一起，生成程序的可执行映像文件。调用gcc的命令行格式与编译汇编语言的格式类似：

`gcc [选项] [-o outfile] infile ...`

其中 infile 是输入的 C 语言文件；outfile 是编译产生的输出文件。对于某次编译过程，并非一定要全部执行这四个阶段，使用命令行选项可以令gcc 编译过程在某个处理阶段后就停止执行。例如，使用`-S` 选项可以让 gcc 在输出了 程序对应的汇编语言程序之后就停止运行；使用`-c`选项可以让 gcc 只生成目标文件而不执行链接处理，见如下所示。


- `gcc -o hello hello.c ` //编译 hello.c 程序，生成执行文件 hello。

- `gcc -S -o hello.s hello.c` /／编译 hello.c 程序，生成对应汇编程序 hello.s。 

-  `gcc -c -o hello.o hello.c`　/／编译hello.c 程序，生成对应目标文件hello.o而不链接。


---

在编译象Linux 内核这样的包含很多源程序文件的大型程序时，通常使用 make 工具软件对整个程序的编译过程进行自动管理，详见后面说明。

### 3.3.2 嵌入汇编

本节介绍内核C语言程序中接触到的嵌入式汇编（内联汇编）语句。由于我们通常编制C程序过程中一般很少用到嵌入式汇编代码，因此这里有必以要对其基本格式和使用方法进行说明。具有输入和输出参数的嵌入汇编语句的基本格式为：  


> asm（“汇编语句”  
> ：输出寄存器  
> ：输入寄存器  
> ：会被修改的寄存器）；  


- 除第1行以外，后面带冒号的行若不使用就都可以省略。其中，”asm”是内联汇编语句关键词；”汇编语句”是你写汇编指令的地方；“输出寄存器”表示当这段嵌入汇编执行完之后，哪些寄存器用于存放输出数据。此地，这些寄存器会分别对应一C语言表达式值或一个内存地址；“输入寄存器”表示在开始执行汇编代码时，这里指定的一些寄存器中应存放的输入值，它们也分别对应着一C变量或常数值。“会被修改的寄存器”表示你已对其中列出的寄存器中的值进行了改动，gcc编译器不能再依赖于它原先对这些寄存器加载的值。如果必要的话，gcc 需要重新加载这些寄存器。因此我们需要把那些没有在输出/输入寄存器部分列出，但是在汇编语句中明确使用到或隐含使用到的寄存器名列在这个部分中。


下面我们用例子来说明嵌入汇编语句的使用方法。这里列出了kernel/traps.c 文件中第 22 行开始的　段代码作为例子来详细解说。为了能看得更清楚一些，我们对这段代码进行了重新排列和编号。

> #define get_seg_byte(seg,addr) \  
> ({ \    
> register char __res;  \  
> __asm__ ("push %%fs; \  
>   mov %%ax, %%fs; \  
>    movb %%fs :%2, %%al ; \  
>   pop %%fs" \  
>   :"=a" (__res) \  
>   :"0"(seg),"m" (*(addr)));\    
> __res;})


- 这段10行代码定义了一个嵌入汇编语言宏函数。通常使用汇编语句最方便的方式是把它们放在一个宏内。用圆括号括住的组合语句（花括号中的语句）：“({})”可以作为表达式使用，其中最后一行上的变量 __res（第10行）是该表达式的输出值，见下一节说明。

- 因为宏语句需要定义在一行上，因此这里使用反斜杠将这些语句连成一行。这条宏定义将被替换到程序中引用该宏名称的地方。第 1 行定义了宏的名称，也即是宏函数名称 get_seg_byte(seg,addr)。第 3 行定义了一个寄存器变量res。该变量将被保存在一个寄存器中，以便于快速访问和操作。如果想指定寄存器（例如 eax），那么我们可以把该句写成`register char __res asm ("ax");`，其中"asm"也可以写成"__asm__"。第 4 行上的"asm"表示嵌入汇编语句的开始。从第 4 行到第 7 行的 4 条语句是 AT＆T格式　的汇编语句。另外，**为了让gcc编译产生的汇编语言程序中寄存器名称前有一个百分号"%”，在嵌入汇编语句寄存器名称前就必须写上两个百分号“%%”**。

- 第8行即是输出寄存器，这句的含义是在这段代码运行结束后将 eax 所代表的寄存器的值放入，__res　变量中，作为本函数的输出值，"=a"中的"a"称为加载代码，"="表示这是输出寄存器，并且其中的值将被输出值替代。第9行表示在这段代码开始运行时将 seg放到eax 寄存器中，**"0"表示使用与上面同个位置的输出相同的寄存器。**而`(*(addr))`表示一个内存偏移地址值。
- **为了在上面汇编语句中使用该地址值，嵌入汇编程序规定把输出和输入寄存器统一按顺序编号，顺序是从输出寄存器序列从左到右从上到下以"%0"升始，分别记为%0、%1、...%9。因此，输出寄存器的编号是%0（这里只有一个输出寄存器），输入寄存器前一部分("0"(seg))的编号是%1，而后部分的编号是%2。上面第6行上的%2即代表`(*(addr))`这个内存偏移量。**

- 现在我们来研究4--7行上的代码的作用。第一句将fs 段寄存器的内容入栈；第二句将eax中的段值赋给 fs 段寄存器；第三句是把 `fs:(*(addr))`所指定的字节放入al 寄存器中。当执行完汇编语句后，输出寄存器eax 的值将被放入__res，作为该宏函数（块结构表达式）的返回值。

- 通过上面分析，我们知道，宏名称中的 seg 代表一指定的内存段值，而 addr表示一内存偏移地址量。到现在为止，我们应该很清楚这段程序的功能了吧！该宏函数的功能是从指定段和偏移值的内存地址处取一个字节。

-----

表3-4 常用寄存器加载代码说明（**重要！！**）（见原文50页表格）

------

...



### 3.3.3 圆括号中的组合语句

花括号对”{…}”用于把变量声明和语句组合成一个复合语句（组合语句）或一个语句块，这样**在语义上这些语句就等同于一条语句**。组合语句的右花括号后面不需要使用分号。圆括号中的组合语句，即形　如"({...})"的语句，可以在 GNU C 中用作一个表达式使用。这样就可以在表达式中使用 loop、switch语句和局部变量，因此这种形式的语句通常称为语句表达式。语句表达式具有如下示例的形式：

> ({int y = foo(); int z;   
> if (y > 0) z = y;  
> else z = -y;   
> 3 + z；})


其中组合语句中最后一条语句必须是后面跟随一个分号的表达式。这个表达式（”3十z”）的值即用作整个圆括号括住语句的值。如果最后一条语句不是表达式，那么整个语句表达式就具有void类型，因此没有值。另外，这种表达式中语句声明的任何局部变量都会在整块语句结束后失效。这个示例语句可以象如下形式的赋值语句来使用：

> res = x + ({略...}) + b;


当然，人们通常不会象上面这样写语句，这种语句表达式通常者都用来定义宏。例如内核源代码init/main.c 程序中读取CMOS时钟信息的宏定义：

> 69 #define CMOS_READ(addr)({\  //最后反斜杠起连接两行语句的作用。  
> 70 outb_p(0x80|addr,0x70); \  //首先向I/0端口0x70输出欲读取的位置addr。  
> 71 inb_p(0x71);\  //然后从端口0x71读入该位置处的值作为返回值。  
> 72 })


---
示例二


> #define inb(port)({\  
> unsigned char _v;\  
> __asm__ volatile ("inb %%dx,%%al":"=a" (_v):"d"(port));\   
> _v;\  
>  })

----


### 3.3.4 寄存器变量

如果想在嵌入汇编语句中把汇编指令的输出首接写到指定的寄存器中，那么此时使用局部寄存器变量，就很方便。由于linux内核中通常只使用局部奇存器变量，因此这里我只对局部奇存器变量的使用方法进行讨论。在GNU C程序中我们可以在函数中用如下形式定义一个局部寄存器变量：

`register int res _asm("ax");`

这单ax是变量 res所希望使用的寄存器。定义这样一个寄存器变量并不会专保留这个寄存器不派其他用途。在程序编译过程中，当gcc 数据流控制确定变量的值已经个用时就可能将该寄存器派作其他用途，而且对它的引用可能会被删除、移动或被简化。另外，gcc并个保证所编译出的代码会把变量一直放在指定的寄存器中。因此在嵌入汇编的指令部分最好不要明确地引用该寄存器并且假设该寄存器肯定引用的是该变量值。然而把该变量用作为asm的操作数还是能够保证指定的寄存器被用作该操作数。

### 3.3.5 内联函数（**没看懂**）

- 在程序中，通过把一个函数声明为内联（inline）函数，就可以让gcc 把函数的代码集成到调用该函数的代码中去。这样处理可以去掉函数调用时进入/退出时间开销，从而肯定能够加快执行速度。

- 内联函数嵌入调用者代码中的操作是一种优化操作，因此只有进行优化编译时才会执行代码嵌入处理。若编译过程中没有使用优化选项"-0"，那么内联函数的代码就不会被真止地嵌入到调用者代码中，而是只作为普通函数调用来处理。把一个函数声明为内联函数的方法是在函数声明中使用关键词”inine”。

- **详细说明见原书P53**


## 3.4 C与汇编程序的相互调用

### 3.4.1 C函数调用机制

- 在Linux内核程序boot/head.s执行完基本初始化操作之后，就会跳转去执行 init/main.c 程序。那么head.s 程序是如何把执行控制转交给init/main.c 程序的呢？汇编程序是如何调用执行C语言程序的？这里我们首先描述一下C函数的调用机制、控制权传递方式，然后说明head.s 程序跳转到C程序的方法。

- 函数调用操作包括从一块代码到另一块代码之间的双向数据传递和执行控制转移。数据传递通过函数参数和返回值来进行。另外，我们还需要在进入函数时为函数的局部变量分配存诸空间，并且在退出函数时收这部分空间。Intel80x86 CPU为控制传递提供了简单的指令，而数据的传递和局部变量存诸空间的分配与回收则通过栈操作来实现。


#### 3.4.1.1 栈帧结构和控制转移权方式



### 3.4.3

P62









2024.12.20-    于昆明