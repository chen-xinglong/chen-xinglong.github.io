
# 第三章 内核编程语言及环境

## 3.1 as86汇编器

Linux 0.1x系统是用来两种汇编器(Assembler)：
- as86汇编器，能产生16位代码，使用配套的ld86链接器。  
- GNU的gas(as)汇编器，使用GNU ld链接器链接产生目标文件。   
---

- as86和ld86是由MINIX-386的主要开发者Bruce Evans编写的Intel8086、80386汇编编译程序和链接程序。   
- 被Linux系统用来创建16位的启动扇区引导程序**boot/bootsect.s**和实模式下初始设置程序**boot/setup.s**的二进制执行代码。  
- as86语法是基于MINIX系统的汇编语言语法，而MINIX系统的汇编语法是基于PC/IX系统的汇编器语法。PC/IX是很早以前Intel 8086 CPU上运行的一个UNIX类操作系统。  

---

有关as86编译器和ld86连接器的源代码可以从FTP服务器<ftp.funet.fi>上或从网站<www.oldlinux.org>下载。

### 3.1.1 as86汇编语言语法


- 汇编器专门用来把低级汇编语言程序编译成含机器码的二进制程序或目标文件。汇编器会把输入的一
个汇编语言程序（例如 srcfile）编译成目标文件（objfile）。  
- 汇编的命令行基本格式为：  
`as [选项] -o objfile srcfile`  其中选项用来控制编译过程以产生指定格式和设置的目标文件。  
- 输入的汇编语言程序srcfile是一个文本文件。该文件内容必须是由换行字符结尾的一系列文本行组成。  

----

- **语句**可以是只包含空格、制表符和换行符的空行，也可以是**赋值语句（或定义语句）、伪操作符语句和机器指令语句**。
- **赋值语句**用于给一个符号或标识符赋值。它由标识符后跟一个等于号，再跟一个表达式组成，例如：`B0OTSEG=OxO7CO`。- **伪操作符语句**是汇编器使用的指示符，它通常并不会产生任何代码。它由伪操作码和0个或多个操作数组成。每个操作码都由一个**点字符'.'**开始。点字符'.'本身是一个特殊的符号，它表示编译过程中的**位置计数器**。其值是点符号出现处机器指令第1个字节的地址。  
- **机器指令语句**是可执行机器指令的助记符，它由操作码和0个或多个操作数构成。另外，任何语句之前都可以有**标号**。*标号是由一个标识符后跟一个冒号’：’组成。在编译过程中，当汇编器遇到一个标号，那么当前位置计数器的值就会赋值给这个标号。*因此一条汇编语句通常由**标号（可选）、指令助记符（指令名）和操作数**三个字段组成，标号位于一条指令的第一个字段。它代表其所在位置的地址，通常指明一个跳转指令的目标位置。最后还可以跟随用注释符开始的注释部分。

---

**汇编器编译产生的目标文件格式**  
- objfile 通常起码包含三个段或区（section），即**正文段（.text）、数据段（.data）和未初始化数据段（.bss）**。  
- **正文段（或称为代码段）**是一个已初始化过的段，通常其中包含程序的执行代码和只读数据。  
- **数据段**也是一个已初始化过的段，其中包含有可读/写的数据。  
- 而**未初始化数据段**是一个未初始化的段。通常汇编器产生的输出目标文件中不会为该段保留空间，但在目标文件链接成执行程序被加载时操作系统会把该段的内容全部初始化为O。在编译过程中，汇编语言程序中会产生代码或数据的语句，都会在这三个中的一个段中生成代码或数据。编译产生的字节会从'.text'段开始存放。  

### 3.1.2 as86汇编语言程序

**框架示例程序boot.s**  
<details>
  <summary>boot.s代码</summary>
1!
2!boot.s -－bootsect.s 的框架程序。用代码 0x07 替换串 msg1 中1字符，然后在屏幕第1行上显示。
3!
4 .globl begtext, begdata, begbss, endtext, enddata, endbss !全局标识符，供ld86 链接使用；
5.text   !正文段;
6 begtext:
7.data !数据段;
8 begdata:
9.bss !未初始化数据段;
10 begbss:
11.text !正文段;
12 B00TSEG = 0x07c0
！BIOS 加载 bootsect 代码的原始段地址;
13
14 entry start
！告知链接程序，程序从 start 标号处开始执行。
15 start:
16 jmpi go, BOOTSEG
！段间跳转。INITSEG指出跳转段地址，标号 go 是偏移地址。
17 go: mov ax, cs 
！段寄存器 cs 值-->ax，用于初始化数据段寄存器 ds 和 es。
18 mov ds, ax
19 mov es,ax
20 mov [msg1+17], ah
！0x07-->替换字符串中1个点符号，喇叭将会鸣一声。
21 mov cx, #20
！共显示20个字符，包括回车换行符。
22 mov dx,#0x1004  !字符串将显示在屏幕第17行、第5列处。
23 mov bx, #0x000c
！字符显示属性（红色）。
24 mov bp, #msgl
指向要显示的字符串（中断调用要求）。
25 mov ax, #0x1301
写字符串并移动光标到串结尾处。
26 int 0x10
！BI0S 中断调用0x10，功能0x13，子功能01。
27 loopl: jmp loopl
！死循环。
28 msgl: .ascii "Loading system . ！调用BIOS中断显示的信息。共2O个ASCII码字符。
29 .byte 13,10
30 .org 510
！表示以后语句从地址510(0x1FE)开始存放。
31 .word 0xAA55
！有效引导扇区标志，供BIOS 加载引导扇区使用。
32 .text
33 endtext:
34 .data
35 enddata:
36 .bss
37 endbss:
</details>


boot.s程序说明：  
- 该程序是一个简单的引导扇区启动程序。编译链接产生的执行程序可以放入软盘第1个扇区直接用来引导计算机启动。启动后会在屏幕第17行、第5列处显示出红色字符串"Loading system.."，并且光标下移一行。然后程序就在第 27行上死循环。    
- 该程序开始的3行是注释语句。在as86汇编语言程序中，凡是以感叹号’！’或分号’；’开始的语句其后
面均为注释文字。  
- 第 4 行上的'globl'是一个伪操作码，而其后面的标号’begtext，begdata，begbss’等标号就是它的操作数。标号是后面带冒号的标识符，例如第6行上的'begtext：’。但是在引用一个标号时无须带冒号。  


---

#### 常用as86伪操作符，以boot.s为例

- '.globl'是汇编指示符（或称为汇编伪指令、伪操作符），后跟0个或多个操作数组成。用于定义所后的标号标识符是外部的或全局的，并且即使不使用也强制引入。 'golbl'后面的标号'begtext,begdata...'等为其操作数。引用一个标号时无须带冒号。  
- 第5到11行除了定义了3个标号，还定义了3个伪操作符:'.text'、‘.data’、‘.bbs’。他们分别对应汇编程序编译产生目标文件中的3个段，即正文段、数据段和未初始化数据段。'.text'用于标识正文段的开始位置，并把切换到text段；'.data'用于标识数据段的开始位置，并把当前段切换到data段；而'.bbs'则用于标识一个未初始化的数据段的开始，并把当前段改变成bbs段。因此5--11行用于在每个段中定义一个标号，最后再切换到text段开始编写随后的代码。 示例程序实际不分段。















2024.11.16-      泰安、