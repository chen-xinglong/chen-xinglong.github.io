
# 第三章 内核编程语言及环境

## 3.1 as86汇编器

Linux 0.1x系统是用来两种汇编器(Assembler)：
- as86汇编器，能产生16位代码，使用配套的ld86链接器。  
- GNU的gas(as)汇编器，使用GNU ld链接器链接产生目标文件。   
---

- as86和ld86是由MINIX-386的主要开发者Bruce Evans编写的Intel8086、80386汇编编译程序和链接程序。   
- 被Linux系统用来创建16位的启动扇区引导程序**boot/bootsect.s**和实模式下初始设置程序**boot/setup.s**的二进制执行代码。  
- as86语法是基于MINIX系统的汇编语言语法，而MINIX系统的汇编语法是基于PC/IX系统的汇编器语法。PC/IX是很早以前Intel 8086 CPU上运行的一个UNIX类操作系统。  

---

有关as86编译器和ld86连接器的源代码可以从FTP服务器<ftp.funet.fi>上或从网站<www.oldlinux.org>下载。

### 3.1.1 as86汇编语言语法


- 汇编器专门用来把低级汇编语言程序编译成含机器码的二进制程序或目标文件。汇编器会把输入的一
个汇编语言程序（例如 srcfile）编译成目标文件（objfile）。  
- 汇编的命令行基本格式为：  
`as [选项] -o objfile srcfile`  其中选项用来控制编译过程以产生指定格式和设置的目标文件。  
- 输入的汇编语言程序srcfile是一个文本文件。该文件内容必须是由换行字符结尾的一系列文本行组成。  

----

- **语句**可以是只包含空格、制表符和换行符的空行，也可以是**赋值语句（或定义语句）、伪操作符语句和机器指令语句**。
- **赋值语句**用于给一个符号或标识符赋值。它由标识符后跟一个等于号，再跟一个表达式组成，例如：`B0OTSEG=OxO7CO`。- **伪操作符语句**是汇编器使用的指示符，它通常并不会产生任何代码。它由伪操作码和0个或多个操作数组成。每个操作码都由一个**点字符'.'**开始。点字符'.'本身是一个特殊的符号，它表示编译过程中的**位置计数器**。其值是点符号出现处机器指令第1个字节的地址。  
- **机器指令语句**是可执行机器指令的助记符，它由操作码和0个或多个操作数构成。另外，任何语句之前都可以有**标号**。*标号是由一个标识符后跟一个冒号’：’组成。在编译过程中，当汇编器遇到一个标号，那么当前位置计数器的值就会赋值给这个标号。*因此一条汇编语句通常由**标号（可选）、指令助记符（指令名）和操作数**三个字段组成，标号位于一条指令的第一个字段。它代表其所在位置的地址，通常指明一个跳转指令的目标位置。最后还可以跟随用注释符开始的注释部分。

---

**汇编器编译产生的目标文件格式**  
- objfile 通常起码包含三个段或区（section），即**正文段（.text）、数据段（.data）和未初始化数据段（.bss）**。  
- **正文段（或称为代码段）**是一个已初始化过的段，通常其中包含程序的执行代码和只读数据。  
- **数据段**也是一个已初始化过的段，其中包含有可读/写的数据。  
- 而**未初始化数据段**是一个未初始化的段。通常汇编器产生的输出目标文件中不会为该段保留空间，但在目标文件链接成执行程序被加载时操作系统会把该段的内容全部初始化为O。在编译过程中，汇编语言程序中会产生代码或数据的语句，都会在这三个中的一个段中生成代码或数据。编译产生的字节会从'.text'段开始存放。  

### 3.1.2 as86汇编语言程序

**框架示例程序boot.s**  
<details>
  <summary>boot.s代码</summary>
1!
2!boot.s -－bootsect.s 的框架程序。用代码 0x07 替换串 msg1 中1字符，然后在屏幕第1行上显示。
3!
4 .globl begtext, begdata, begbss, endtext, enddata, endbss !全局标识符，供ld86 链接使用；
5.text   !正文段;
6 begtext:
7.data !数据段;
8 begdata:
9.bss !未初始化数据段;
10 begbss:
11.text !正文段;
12 B00TSEG = 0x07c0
！BIOS 加载 bootsect 代码的原始段地址;
13
14 entry start
！告知链接程序，程序从 start 标号处开始执行。
15 start:
16 jmpi go, BOOTSEG
！段间跳转。INITSEG指出跳转段地址，标号 go 是偏移地址。
17 go: mov ax, cs 
！段寄存器 cs 值-->ax，用于初始化数据段寄存器 ds 和 es。
18 mov ds, ax
19 mov es,ax
20 mov [msg1+17], ah
！0x07-->替换字符串中1个点符号，喇叭将会鸣一声。
21 mov cx, #20
！共显示20个字符，包括回车换行符。
22 mov dx,#0x1004  !字符串将显示在屏幕第17行、第5列处。
23 mov bx, #0x000c
！字符显示属性（红色）。
24 mov bp, #msgl
指向要显示的字符串（中断调用要求）。
25 mov ax, #0x1301
写字符串并移动光标到串结尾处。
26 int 0x10
！BI0S 中断调用0x10，功能0x13，子功能01。
27 loopl: jmp loopl
！死循环。
28 msgl: .ascii "Loading system . ！调用BIOS中断显示的信息。共2O个ASCII码字符。
29 .byte 13,10
30 .org 510
！表示以后语句从地址510(0x1FE)开始存放。
31 .word 0xAA55
！有效引导扇区标志，供BIOS 加载引导扇区使用。
32 .text
33 endtext:
34 .data
35 enddata:
36 .bss
37 endbss:
</details>


boot.s程序说明：  
- 该程序是一个简单的引导扇区启动程序。编译链接产生的执行程序可以放入软盘第1个扇区直接用来引导计算机启动。启动后会在屏幕第17行、第5列处显示出红色字符串"Loading system.."，并且光标下移一行。然后程序就在第 27行上死循环。    
- 该程序开始的3行是注释语句。在as86汇编语言程序中，凡是以感叹号’！’或分号’；’开始的语句其后
面均为注释文字。  
- 第 4 行上的'globl'是一个伪操作码，而其后面的标号’begtext，begdata，begbss’等标号就是它的操作数。标号是后面带冒号的标识符，例如第6行上的'begtext：’。但是在引用一个标号时无须带冒号。  


---

#### 常用as86伪操作符，以boot.s为例

- '.globl'是汇编指示符（或称为汇编伪指令、伪操作符），后跟0个或多个操作数组成。用于定义所后的标号标识符是外部的或全局的，并且即使不使用也强制引入。 **'golbl'后面的标号'begtext,begdata...'等为其操作数。引用一个标号时无须带冒号。**  
- 第5到11行除了定义了3个标号，还定义了3个伪操作符:'.text'、‘.data’、‘.bbs’。他们分别对应汇编程序编译产生目标文件中的3个段，即正文段、数据段和未初始化数据段。'.text'用于标识正文段的开始位置，并把切换到text段；'.data'用于标识数据段的开始位置，并把当前段切换到data段；而'.bbs'则用于标识一个未初始化的数据段的开始，并把当前段改变成bbs段。因此5--11行用于在每个段中定义一个标号，最后再切换到text段开始编写随后的代码。 示例程序实际不分段。  
- 第十四行上的标识符'entry'是保留关键字，用于迫使链接器ld86在生成的可执行文件中包括进其后指定的标号'start'。通常在链接多个目标文件生成一个可执行文件时应该在其中一个汇编程序中用关键词entry指定一个入口标号。  
---
##### **8086汇编指令-jmpi**
参考链接：[8086 jmpi详解](https://blog.csdn.net/jackailson/article/details/83755157)  

在boot.s中，为了改变cs的值，操作方法如下：  
```
entry start
start:
  jmpi go,#BOOTSEG  !jmpi为段间转移指令(inter-segment)，即跳转到'#BOOTSEG:go'位置（CS：IP）继续执行。
go:
  mov ax,cs
```

CS、IP两个寄存器是不能用MOV指令修改的，他们指示了要读取指令的地址。只能使用转移指令来修改。  

如`jmpi 0,0x9000h`即表示跳转到9000:0（CS：IP）位置继续执行了。  

---


- 第十六行是段间（Inter-segment）远跳转语句。该语句执行后CS:IP=0x07C0:0x0005。对于20位总线长度，实际寻址地址为(0x07c00+0x0005=0x07c05)

##### as86寻址方式

1. 直接寄存器寻址：
mov bx,ax
jmp bx  
2. 间接寄存器寻址：
mov [bx],ax
jmp [bx]  !**as86中，间接操作需要使用方括号对**  
3. !把立即数 1234放到ax中。把msg1地址值放到ax中。
mov ax,#1234  
mov ax,#msg1  
4. 绝对寻址。把内存地址1234（msg1）处的内容放入ax中。
mov ax,1234
mov ax,msg1
mov ax,[msg1]  
5. 索引寻址
mov ax,msg1[bx]  

---

- 第 21--25行的语句分别用于把立即数放到相应的寄存器中。立即数前一定要加并号’#’，否则将作为内存地址使用而使语句变成绝对寻址语句，见上面示例。另外，把一个标号（例如msg1）的地址值放入寄存器中时也一定要在前面加'#'，否则会变成msg1地址处的内容放到「寄存器中！  
- 第26行是BI0S屏幕显示中断调用int 0x10。这里使用其功能19、子功能1。该中断的作用是把一字符串（msg1）写到屏幕指定位置处。寄存器cx中是学符串长度值，dx中是显示位置值，bx中是显示使用的学符属性，es：bp指向字符串。  
- 第27行是一个跳转语句，跳转到当前指令处。因此这是一个死循环语句。这里采用死循环语句是为了让显示的内容能够停留在屏幕上而不被删除。  
- 第28--29行定义了字符串 msgl。定义字符串需要使用伪操作符’.ascii’，并且需要使用双引号括住学符串。伪操作符‘asciiz’还会自动在学符串后添加一个NULL（O）字符。另外，第29行上定义 回车和换行（13,10）两个字符。定义字符需要使用伪操作符’.byte’，并且需要使用单引号把字符括住。例如：“’D’”。当然我们也可以象示例中的一样直接写出字符的 ASCII码。  
- 第30行上的伪操作符语句，‘org’定义了当前汇编的位置。这条语句会把汇编器编译过程中当前段的位置计数器值调整为该伪操作符语句上给出的值。对于本示例程序，该语句把位置计数器设置为510，并在此处（第31行）放置了有效引导扇区标志字0xAA55。伪操作符’.word’用于在当前位置定义一个双字节内存对象（变量），其后可以是一个数或者是一个表达式。由于后面没有代码或数据了，因此我们可以据此确定boot.s编译出来的执行程序应该止好为512字节。  
- 第32--37行又在三个段中分别放置了三个标号。分别用来表示三个段的结束位置。这样设置可以用来在链接多个目标模块时区分各个模块中各段的开始和结束位置。由于内核中的 bootsec.s 和 setup.s 程序都是单独编译链接的程序，各自期望生成的者都是纯二进制文件而并没有与其他目标模块文件进行链接，因此示例程序中声明各个段的伪操作符（.text、.data和.bss）都完全可以省略掉，即程序中第4--l1行和32--37行可以全部删除也能编译链接产生出正确的结果。  

### 3.1.3 as86汇编语言程序的编译和链接














2024.11.16-      于泰安、昆明