
## 3.3 C语言程序

GNU gcc 对 ISO 标准 C89 描述的 C语言进行了一些扩展。

### 3.3.1 C程序编译和链接

使用gcc汇编器编译C语言程序时通常会经过四个处理阶段，即**预处理阶段、编译阶段、汇编阶段和链接阶段**，如下图所示。

![p3-1](../linux011image/p3-c/p3-1.png)


- 在前处理阶段中，gcc 会把C程序传递给 C 前处理器CPP，对 C语言程序中**指示符和宏**进行替换处理，
输出纯C语言代码；

- 在编译阶段，gcc把C语言程序编译生成对应的与机器相关的as汇编语言代码；

- 在汇编阶段，as汇编器会把汇编代码转换成机器指令，并以特定二进制格式输出保存在标文件中；最后GNU ld链接器把程序的相关目标文件组合链接在一起，生成程序的可执行映像文件。调用gcc的命令行格式与编译汇编语言的格式类似：

`gcc [选项] [-o outfile] infile ...`

其中 infile 是输入的 C 语言文件；outfile 是编译产生的输出文件。对于某次编译过程，并非一定要全部执行这四个阶段，使用命令行选项可以令gcc 编译过程在某个处理阶段后就停止执行。例如，使用`-S` 选项可以让 gcc 在输出了 程序对应的汇编语言程序之后就停止运行；使用`-c`选项可以让 gcc 只生成目标文件而不执行链接处理，见如下所示。


- `gcc -o hello hello.c ` //编译 hello.c 程序，生成执行文件 hello。

- `gcc -S -o hello.s hello.c` /／编译 hello.c 程序，生成对应汇编程序 hello.s。 

-  `gcc -c -o hello.o hello.c`　/／编译hello.c 程序，生成对应目标文件hello.o而不链接。


---

在编译象Linux 内核这样的包含很多源程序文件的大型程序时，通常使用 make 工具软件对整个程序的编译过程进行自动管理，详见后面说明。

### 3.3.2 嵌入汇编

本节介绍内核C语言程序中接触到的嵌入式汇编（内联汇编）语句。由于我们通常编制C程序过程中一般很少用到嵌入式汇编代码，因此这里有必以要对其基本格式和使用方法进行说明。具有输入和输出参数的嵌入汇编语句的基本格式为：  


> asm（“汇编语句”  
> ：输出寄存器  
> ：输入寄存器  
> ：会被修改的寄存器）；  


- 除第1行以外，后面带冒号的行若不使用就都可以省略。其中，”asm”是内联汇编语句关键词；”汇编语句”是你写汇编指令的地方；“输出寄存器”表示当这段嵌入汇编执行完之后，哪些寄存器用于存放输出数据。此地，这些寄存器会分别对应一C语言表达式值或一个内存地址；“输入寄存器”表示在开始执行汇编代码时，这里指定的一些寄存器中应存放的输入值，它们也分别对应着一C变量或常数值。“会被修改的寄存器”表示你已对其中列出的寄存器中的值进行了改动，gcc编译器不能再依赖于它原先对这些寄存器加载的值。如果必要的话，gcc 需要重新加载这些寄存器。因此我们需要把那些没有在输出/输入寄存器部分列出，但是在汇编语句中明确使用到或隐含使用到的寄存器名列在这个部分中。


下面我们用例子来说明嵌入汇编语句的使用方法。这里列出了kernel/traps.c 文件中第 22 行开始的　段代码作为例子来详细解说。为了能看得更清楚一些，我们对这段代码进行了重新排列和编号。

> #define get_seg_byte(seg,addr) \  
> ({ \    
> register char __res;  \  
> __asm__ ("push %%fs; \  
>   mov %%ax, %%fs; \  
>    movb %%fs :%2, %%al ; \  
>   pop %%fs" \  
>   :"=a" (__res) \  
>   :"0"(seg),"m" (*(addr)));\    
> __res;})


- 这段10行代码定义了一个嵌入汇编语言宏函数。通常使用汇编语句最方便的方式是把它们放在一个宏内。用圆括号括住的组合语句（花括号中的语句）：“({})”可以作为表达式使用，其中最后一行上的变量 __res（第10行）是该表达式的输出值，见下一节说明。

- 因为宏语句需要定义在一行上，因此这里使用反斜杠将这些语句连成一行。这条宏定义将被替换到程序中引用该宏名称的地方。第 1 行定义了宏的名称，也即是宏函数名称 get_seg_byte(seg,addr)。第 3 行定义了一个寄存器变量res。该变量将被保存在一个寄存器中，以便于快速访问和操作。如果想指定寄存器（例如 eax），那么我们可以把该句写成`register char __res asm ("ax");`，其中"asm"也可以写成"__asm__"。第 4 行上的"asm"表示嵌入汇编语句的开始。从第 4 行到第 7 行的 4 条语句是 AT＆T格式　的汇编语句。另外，**为了让gcc编译产生的汇编语言程序中寄存器名称前有一个百分号"%”，在嵌入汇编语句寄存器名称前就必须写上两个百分号“%%”**。

- 第8行即是输出寄存器，这句的含义是在这段代码运行结束后将 eax 所代表的寄存器的值放入，__res　变量中，作为本函数的输出值，"=a"中的"a"称为加载代码，"="表示这是输出寄存器，并且其中的值将被输出值替代。第9行表示在这段代码开始运行时将 seg放到eax 寄存器中，**"0"表示使用与上面同个位置的输出相同的寄存器。**而`(*(addr))`表示一个内存偏移地址值。
- **为了在上面汇编语句中使用该地址值，嵌入汇编程序规定把输出和输入寄存器统一按顺序编号，顺序是从输出寄存器序列从左到右从上到下以"%0"升始，分别记为%0、%1、...%9。因此，输出寄存器的编号是%0（这里只有一个输出寄存器），输入寄存器前一部分("0"(seg))的编号是%1，而后部分的编号是%2。上面第6行上的%2即代表`(*(addr))`这个内存偏移量。**

- 现在我们来研究4--7行上的代码的作用。第一句将fs 段寄存器的内容入栈；第二句将eax中的段值赋给 fs 段寄存器；第三句是把 `fs:(*(addr))`所指定的字节放入al 寄存器中。当执行完汇编语句后，输出寄存器eax 的值将被放入__res，作为该宏函数（块结构表达式）的返回值。

- 通过上面分析，我们知道，宏名称中的 seg 代表一指定的内存段值，而 addr表示一内存偏移地址量。到现在为止，我们应该很清楚这段程序的功能了吧！该宏函数的功能是从指定段和偏移值的内存地址处取一个字节。

-----

表3-4 常用寄存器加载代码说明（**重要！！**）（见原文50页表格）

------

...



### 3.3.3 圆括号中的组合语句

花括号对”{…}”用于把变量声明和语句组合成一个复合语句（组合语句）或一个语句块，这样**在语义上这些语句就等同于一条语句**。组合语句的右花括号后面不需要使用分号。圆括号中的组合语句，即形　如"({...})"的语句，可以在 GNU C 中用作一个表达式使用。这样就可以在表达式中使用 loop、switch语句和局部变量，因此这种形式的语句通常称为语句表达式。语句表达式具有如下示例的形式：

> ({int y = foo(); int z;   
> if (y > 0) z = y;  
> else z = -y;   
> 3 + z；})


其中组合语句中最后一条语句必须是后面跟随一个分号的表达式。这个表达式（”3十z”）的值即用作整个圆括号括住语句的值。如果最后一条语句不是表达式，那么整个语句表达式就具有void类型，因此没有值。另外，这种表达式中语句声明的任何局部变量都会在整块语句结束后失效。这个示例语句可以象如下形式的赋值语句来使用：

> res = x + ({略...}) + b;


当然，人们通常不会象上面这样写语句，这种语句表达式通常者都用来定义宏。例如内核源代码init/main.c 程序中读取CMOS时钟信息的宏定义：

> 69 #define CMOS_READ(addr)({\  //最后反斜杠起连接两行语句的作用。  
> 70 outb_p(0x80|addr,0x70); \  //首先向I/0端口0x70输出欲读取的位置addr。  
> 71 inb_p(0x71);\  //然后从端口0x71读入该位置处的值作为返回值。  
> 72 })


---
示例二


> #define inb(port)({\  
> unsigned char _v;\  
> __asm__ volatile ("inb %%dx,%%al":"=a" (_v):"d"(port));\   
> _v;\  
>  })

----


### 3.3.4 寄存器变量

如果想在嵌入汇编语句中把汇编指令的输出首接写到指定的寄存器中，那么此时使用局部寄存器变量，就很方便。由于linux内核中通常只使用局部奇存器变量，因此这里我只对局部奇存器变量的使用方法进行讨论。在GNU C程序中我们可以在函数中用如下形式定义一个局部寄存器变量：

`register int res _asm("ax");`

这单ax是变量 res所希望使用的寄存器。定义这样一个寄存器变量并不会专保留这个寄存器不派其他用途。在程序编译过程中，当gcc 数据流控制确定变量的值已经个用时就可能将该寄存器派作其他用途，而且对它的引用可能会被删除、移动或被简化。另外，gcc并个保证所编译出的代码会把变量一直放在指定的寄存器中。因此在嵌入汇编的指令部分最好不要明确地引用该寄存器并且假设该寄存器肯定引用的是该变量值。然而把该变量用作为asm的操作数还是能够保证指定的寄存器被用作该操作数。

### 3.3.5 内联函数（**没看懂**）

- 在程序中，通过把一个函数声明为内联（inline）函数，就可以让gcc 把函数的代码集成到调用该函数的代码中去。这样处理可以去掉函数调用时进入/退出时间开销，从而肯定能够加快执行速度。

- 内联函数嵌入调用者代码中的操作是一种优化操作，因此只有进行优化编译时才会执行代码嵌入处理。若编译过程中没有使用优化选项"-0"，那么内联函数的代码就不会被真止地嵌入到调用者代码中，而是只作为普通函数调用来处理。把一个函数声明为内联函数的方法是在函数声明中使用关键词”inine”。

- **详细说明见原书P53**


## 3.4 C与汇编程序的相互调用

### 3.4.1 C函数调用机制

- 在Linux内核程序boot/head.s执行完基本初始化操作之后，就会跳转去执行 init/main.c 程序。那么head.s 程序是如何把执行控制转交给init/main.c 程序的呢？汇编程序是如何调用执行C语言程序的？这里我们首先描述一下C函数的调用机制、控制权传递方式，然后说明head.s 程序跳转到C程序的方法。

- 函数调用操作包括从一块代码到另一块代码之间的双向数据传递和执行控制转移。数据传递通过函数参数和返回值来进行。另外，我们还需要在进入函数时为函数的局部变量分配存诸空间，并且在退出函数时收这部分空间。Intel80x86 CPU为控制传递提供了简单的指令，而数据的传递和局部变量存诸空间的分配与回收则通过栈操作来实现。


#### 3.4.1.1 栈帧结构和控制转移权方式

大多数CPU上的程序实现使用栈来支持函数调用操作。栈被用来传递函数参数、存储返回信息、临时保存寄存器原有值以备恢复以及用来存储局部数据。单个函数调用操作所使用的栈部分被称为**栈帧（Stack frame）**结构。栈帧结构的两端由两个指针来指定。**寄存器 ebp 通常用作帧指针（frame pointer）**，而**esp则用作栈指针（stack pointer）**。在函数执行过程中，栈指针esp 会随着数据的入栈和出栈而移动，因此函数中对大部分数据的访问都基于帧指针ebp进行。如下图所示：

![p3-2.png](../linux011image/p3-c/p3-2.png)


- 对于函数A调用函数B的情况，传递给B的参数包含在A的栈帧中。当A调用B时，函数A的返回地址（**调用返回后继续执行的指令地址**）被压入栈中，栈中该位置也明确指明了A栈帧的结束处。而B的栈帧则从随后的栈部分开始，即图中保存帧指针（ebp）的地方开始。再随后则用于存放任何保存的寄存器值以及函数的临时值。

- B 函数同样也使用栈来保存不能放在寄存器中的局部变量值。例如由于通常CPU的寄存器数量有限而不能够存放函数的所有局部数据，或者有些局部变量是数组或结构，因此必须使用数组或结构引用来访问。

- 还有就是C语言的地址操作符&被应用到一个局部变量上时，我们就需要为该变量生成一个地址，即为变
量的地址指针分配一空间。最后，B函数会使用栈来保存调用任何其它函数的参数。
**栈是往低（小）地址方向扩展的，而 esp 指向当前栈顶处的元素**。通过使用 push 和 pop 指令我们可以把数据压入栈中或从栈中弹出。对于没有指定初始值的数据所需要的存储空间，我们可以通过把栈指针递减适当的值来做到。类似地，通过增加栈指针值我们可以回收栈中已分配的空间。

- 指令CALL和RET用于处理函数调用和返回操作。调用指令CALL的作用是把返回地址压入栈中并且跳转到被调用函数开始处执行。返回地址是程序中紧随调用指令CALL后面一条指令的地址。因此当被调函数返回时就会从该位置继续执行。返回指令RET用于弹出栈顶处的地址并跳转到该地址处。在使用该指令之前，应该先正确处理栈中内容，使得当前栈指针所指位置内容正是先前CALL指令保存的返回地址。

- 另外，**若返回值是一个整数或一个指针，那么寄存器eax将被默认用来传递返回值**。

- 尽管某一时刻只有一个函数在执行，但我们还是需要确定在一个函数（调用者）调用其他函数（被调
用者）时，被调用者不会修改或覆盖掉调用者今后要用到的寄存器内容。因此Intel CPU采用了所有函数
必须遵守的寄存器用法统一惯例。**该惯例指明，寄存器eax、edx和ecx的内容必须由调用者自己负责保存**。当函数B被A调用时，函数B可以在不用保存这些寄存器内容的情况下任意使用它们而不会毁坏函数A所需要的任何数据。**另外，寄存器 ebx、esi和 edi 的内容则必须由*被调用者B* 来保护**。当被调用者需要使
用这些寄存器中的任意一个时，必须首先在栈中保存其内容，并在退出时恢复这些寄存器的内容。因为调
用者A（或者一些更高层的函数）并不负责保存这些寄存器内容，但可能在以后的操作中还需要用到原先的值。还有寄存器 ebp 和 esp 也必须遵守第二个惯例用法（由被调用者B来维护）。

#### 3.4.1.2 函数调用举例

![p3-3.png](../linux011image/p3-c/p3-3.png)


gcc汇编后的汇编代码：
![p3-4.png](../linux011image/p3-c/3-4.png)

![p3-5.png](../linux011image/p3-c/3-5.png)



***其余请参考原书***


#### 3.4.1.3 main()也是一个函数

- 上面这段汇编程序是使用 gcc 1.40 编译产生的，可以看出其中有几行多余的代码。可见当时的 gcc 编译器还不能产生最高效率的代码，这也是为什么某些关键代码需要直接使用汇编语言编制的原因之一。另外，上面提到C程序的主程序 main()也是一个函数。这是因为在编译链接时它将会作为 **crtO.s** 汇编程序的函数被调用。crtO.s 是一个桩（stub）程序，名称中的“crt”是“C run-time”的缩写。该程序的目标文件将被链接在每个用户执行程序的开始部分，主要用于设置一些初始化全局变量等。

- Linux 0.11中crtO.s汇编
程序见如下所示。其中建立并初始化全局变量_environ供程序中其它模块使用。

![p3-6.png](../linux011image/p3-c/3-6.png)

- 通常使用gcc 编译链接生成执行文件时，gcc 会自动把该文件的代码作为第一个模块链接在可执行程序中。在编译时使用显示详细信息选项-v就可以明显地看出这个链接操作过程：

![p3-7.png](../linux011image/p3-c/3-7.png)


- 因此在通常的编译过程中我们无需特别指定 stub 模块 crtO.o，但是若想从上面给出的汇编程序手工使用 ld
（gld）从 exch.o 模块链接产生可执行文件 exch，那么我们就需要在命令行上特别指明 crtO.o 这个模块，并
且链接的顺序应该是“crtO.o、所有程序模块、库文件”。
为了使用 ELF 格式的目标文件以及建立共享库模块文件，现在的 gcc 编译器（2.x）已经把这个 crtO
扩展成几个模块：crtl.o、crti.o、crtbegin.o、crtend.o和 crtn.o。这些模块的链接顺序为“crtl.o、crti.o、crtbegin.0
（crtbeginS.o）、所有程序模块、crtend.o（crtendS.o）、crtn.o、库模块文件”。gcc 的配置文件 specfile 指定了这种链接顺序。其中 ctrl.o、crti.o和 crtn.o 由C库提供，是C程序的“启动”模块；crtbegin.o和 crtend.o
是 C++语言的启动模块，由编译器 gcc 提供；而 crtl.o则与 crto.o 的作用类似，主要用于在调用 main()之
前做一些初始化工作，全局符号_start 就定义在这个模块中。

- crtbegin.o 和 crtend.o主要用于C++语言在.ctors 和.dtors 区中执行全局构造器（constructor）和析构
器（destructor）函数。crtbeginS.o和crtendS.o的作用与前两者类似，但用于创建共享模块中。crti.o用于
在.init区中执行初始化函数init()。.init区中包含进程的初始化代码，即当程序开始执行时，系统会在调用 main()之前先执行.init 中的代码。crtn.o 则用于在.fini 区中执行进程终止退出处理函数 fini()函数，即当程序正常退出时（main()返回之后），系统会安排执行.fini 中的代码。

- boot/head.s程序中第136--140行就是用于为跳转到init/main.c中的main()函数作准备工作。第139行
上的指令在栈中压入了返回地址，而第 140 行则压入了 main())函数代码的地址。当head.s最后在第218行
上执行 ret指令时就会弹出 main())的地址，并把控制权转移到 init/main.c 程序中。

### 3.4.2 在汇编程序中调用C函数






### 3.4.3

P62









2024.12.20-    于昆明